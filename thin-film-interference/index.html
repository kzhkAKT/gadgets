<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>薄膜干渉シミュレーター (Thin Film Interference)</title>
    
    <!-- SEO & OGP Settings -->
    <meta name="description" content="p5.jsを用いた薄膜干渉の物理シミュレーション。膜厚、屈折率、波長、入射角をインタラクティブに変更し、光の干渉現象を可視化します。">
    <meta property="og:title" content="薄膜干渉シミュレーター">
    <meta property="og:description" content="Webブラウザで動く物理シミュレーション。光の波長や膜の厚さを変えて干渉縞の変化を観察できます。">
    <meta property="og:type" content="website">
    <meta name="theme-color" content="#ffffff">

    <!-- Embedded Favicon (Blue Circle) -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><circle cx=%2250%22 cy=%2250%22 r=%2250%22 fill=%22%23007bff%22/></svg>">

    <!-- p5.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #ffffff; /* 白背景 */
            color: #333;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden; /* スクロールバーを隠す */
            touch-action: none; /* モバイルでのスクロール防止 */
            -webkit-user-select: none; /* テキスト選択防止 */
            user-select: none;
        }
        canvas {
            display: block; /* キャンバス下の余白除去 */
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9); /* 白背景（半透明） */
            backdrop-filter: blur(5px); /* 背景をぼかす（対応ブラウザ用） */
            padding: 10px;
            border-radius: 8px;
            width: 200px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1); /* 影を柔らかく */
            max-height: 95vh;
            overflow-y: auto;
            font-size: 11px;
            z-index: 10;
            border: 1px solid rgba(0, 0, 0, 0.1); /* 枠線 */
        }
        /* スクロールバーのカスタマイズ */
        #controls::-webkit-scrollbar {
            width: 6px;
        }
        #controls::-webkit-scrollbar-thumb {
            background-color: rgba(0,0,0,0.2);
            border-radius: 3px;
        }
        h3 {
            margin-top: 0;
            margin-bottom: 8px;
            font-size: 13px;
            color: #000; /* 黒文字 */
            border-bottom: 1px solid #ddd;
            padding-bottom: 4px;
        }
        .control-group {
            margin-bottom: 8px;
        }
        label {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            margin-bottom: 2px;
            color: #333;
        }
        input[type=range] {
            width: 100%;
            cursor: pointer;
            margin: 4px 0;
            -webkit-appearance: none;
            background: transparent;
        }
        /* Range Input Styling */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 14px;
            width: 14px;
            border-radius: 50%;
            background: #007bff; /* 青 */
            cursor: pointer;
            margin-top: -5px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #ddd; /* 薄いグレー */
            border-radius: 2px;
        }
        .value-display {
            font-weight: bold;
            color: #0056b3; /* 濃い青 */
            font-family: 'Courier New', monospace; /* 数値を等幅フォントで */
        }
        button {
            background: #007bff;
            color: #fff;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 11px;
            width: 100%;
            transition: background 0.2s;
            touch-action: manipulation; /* タップの遅延をなくす */
        }
        button:hover {
            background: #0056b3;
        }
        button:active {
            transform: translateY(1px);
        }
        #legend {
            margin-top: 8px;
            font-size: 10px;
            border-top: 1px solid #ddd;
            padding-top: 6px;
            color: #555;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 3px;
        }
        .color-box {
            width: 10px;
            height: 10px;
            margin-right: 5px;
            border-radius: 2px;
            border: 1px solid #ccc; /* 境界線追加 */
        }
        .line-box {
            width: 18px;
            height: 0;
            margin-right: 5px;
            border-top: 2px solid #555;
        }
        .line-dashed {
            border-top: 2px dashed #888;
        }
        /* 著作権表示などフッター的なものが必要ならここに追加 */
        .footer {
            margin-top: 10px;
            text-align: center;
            color: #888;
            font-size: 9px;
        }
    </style>
</head>
<body>

<div id="controls">
    <h3>薄膜干渉パラメータ</h3>
    
    <div class="control-group">
        <label>光の波長: <span id="val-wavelength" class="value-display">500</span> nm</label>
        <input type="range" id="slider-wavelength" min="380" max="750" value="500">
    </div>

    <div class="control-group">
        <label>膜の厚さ: <span id="val-thickness" class="value-display">400</span> nm</label>
        <input type="range" id="slider-thickness" min="100" max="1000" value="400">
    </div>

    <div class="control-group">
        <label>膜の屈折率 ($n_2$): <span id="val-n2" class="value-display">1.4</span></label>
        <input type="range" id="slider-n2" min="1.1" max="2.5" step="0.01" value="1.4">
    </div>

    <div class="control-group">
        <label>基板の屈折率 ($n_3$): <span id="val-n3" class="value-display">1.0</span></label>
        <input type="range" id="slider-n3" min="1.0" max="2.5" step="0.01" value="1.0">
    </div>

    <div class="control-group">
        <label>入射角: <span id="val-theta" class="value-display">30</span> 度</label>
        <input type="range" id="slider-theta" min="0" max="80" value="30">
    </div>

    <!-- 一時停止ボタン -->
    <div class="control-group" style="text-align: center; margin-top: 12px;">
        <button id="btn-pause">一時停止 (Pause)</button>
    </div>

    <div id="legend">
        <div class="legend-item"><div class="color-box" style="background:#fff; border:1px solid #ccc;"></div>空気 ($n_1=1.0$)</div>
        <div class="legend-item"><div class="color-box" style="background:rgba(200,230,255,0.5);"></div>薄膜 ($n_2$)</div>
        <div class="legend-item"><div class="color-box" style="background:linear-gradient(to right, #fff, #555); border:1px solid #ccc;"></div>基板 ($n_3$: 可変)</div>
        <div style="margin-top:4px; border-top:1px dashed #ccc; padding-top:4px;"></div>
        <div class="legend-item"><div class="line-box" style="border-top: 1px solid #555; opacity: 0.5;"></div>入射波/膜内光</div>
        <div class="legend-item"><div class="line-box line-dashed"></div>個別の反射波 (破線)</div>
        <div class="legend-item"><div class="line-box" style="border-top: 2px solid #333;"></div>合成波 (実線)</div>
    </div>
    
    <div class="footer">Built with p5.js</div>
</div>

<script>
    // グローバル変数
    let wavelengthSlider, thicknessSlider, n2Slider, n3Slider, thetaSlider;
    let wavelengthVal, thicknessVal, n2Val, n3Val, thetaVal;
    let pauseButton;
    
    // 定数
    const n1 = 1.0; // 空気の屈折率
    const WAVE_SPEED = 0.1125; // アニメーション速度 (元の0.15から25%ダウン)
    let time = 0;   // アニメーション用
    let isPaused = false; // 一時停止フラグ

    // 重要: 物理シミュレーションと描画の整合性を保つための統一スケール
    const RENDER_SCALE = 0.25; 

    function setup() {
        createCanvas(windowWidth, windowHeight);
        
        // p5.jsのselectを使ってHTML要素を取得
        wavelengthSlider = select('#slider-wavelength');
        thicknessSlider = select('#slider-thickness');
        n2Slider = select('#slider-n2');
        n3Slider = select('#slider-n3');
        thetaSlider = select('#slider-theta');
        pauseButton = select('#btn-pause');

        wavelengthVal = select('#val-wavelength');
        thicknessVal = select('#val-thickness');
        n2Val = select('#val-n2');
        n3Val = select('#val-n3');
        thetaVal = select('#val-theta');

        pauseButton.mousePressed(togglePause);
    }

    function togglePause() {
        isPaused = !isPaused;
        if (isPaused) {
            pauseButton.html("再生 (Play)");
            pauseButton.style('background', '#ff6666'); // 赤系も見やすく
        } else {
            pauseButton.html("一時停止 (Pause)");
            pauseButton.style('background', '#007bff');
        }
    }

    function draw() {
        background(255); // 白背景

        // スライダーの値を取得
        const lambda = float(wavelengthSlider.value()); // 波長 (nm)
        const d = float(thicknessSlider.value());       // 厚さ (nm)
        const n2 = float(n2Slider.value());             // 膜の屈折率
        const n3 = float(n3Slider.value());             // 基板の屈折率
        const theta1Deg = float(thetaSlider.value());   // 入射角 (度)

        // 値を画面表示更新
        wavelengthVal.html(lambda);
        thicknessVal.html(d);
        n2Val.html(nf(n2, 1, 2));
        n3Val.html(nf(n3, 1, 2));
        thetaVal.html(theta1Deg);

        const theta1 = radians(theta1Deg);
        const sinTheta2 = (n1 / n2) * sin(theta1);
        const theta2 = asin(sinTheta2);

        // 描画設定（レスポンシブ対応）
        const visualThickness = d * RENDER_SCALE; 
        const filmTopY = height * 0.45;
        const filmBottomY = filmTopY + visualThickness;
        const centerX = width * 0.45; 

        // --- 視覚的オフセットの計算 ---
        let visualOffset = 0;
        if (theta1Deg < 15) {
            visualOffset = map(theta1Deg, 0, 15, 40, 0);
        }

        const inX = centerX - visualOffset;
        const dx = visualThickness * tan(theta2);
        const exitX = inX + (2 * dx) + (2 * visualOffset);


        // --- レイヤーの描画 (色をライトモード用に調整) ---
        noStroke();
        
        const textOffsetX = (width < 600) ? 120 : 200;

        // 空気
        fill(50); // 文字色：濃いグレー
        text("Air (n=1.0)", centerX - textOffsetX, filmTopY - 10);
        
        // 薄膜 (薄い水色)
        fill(200, 230, 255, 150);
        rect(0, filmTopY, width, visualThickness);
        fill(100); // 文字色：グレー
        text(`Thin Film (n=${nf(n2, 1, 2)}, d=${d}nm)`, centerX - textOffsetX, filmTopY + 20);

        // 基板 (屈折率に応じて色を変える)
        // n3 = 1.0 -> 白(255)
        // n3 = 2.5 -> 濃いグレー(50)
        let subVal = map(n3, 1.0, 2.5, 255, 80); 
        subVal = constrain(subVal, 50, 255);
        fill(subVal);
        rect(0, filmBottomY, width, height - filmBottomY);
        
        fill(50); // 文字色：濃いグレー
        text(`Substrate (n=${nf(n3, 1, 2)})`, centerX - textOffsetX, filmBottomY + 20);

        // 境界線を描く
        stroke(200);
        strokeWeight(1);
        line(0, filmTopY, width, filmTopY);
        line(0, filmBottomY, width, filmBottomY);


        // --- 光線の計算と描画 ---
        const lightColor = wavelengthToColor(lambda);
        
        if (!isPaused) {
            time += WAVE_SPEED;
        }

        const rayLen = min(width, height) * 0.4; 

        // 描画パラメータ (ライトモード用に見やすく濃くする)
        const incidentAlpha = 0.5; // 少し透明度上げても白背景なら見える
        const incidentWeight = 2.0; // 少し太く
        const filmAlpha = 0.3; 
        const filmWeight = 2.0;

        // --- 位相追跡 (Phase Tracking) の開始 ---
        const visualLambda = lambda * RENDER_SCALE; 
        const k_air = TWO_PI / visualLambda;
        
        // 1. 入射光 (Incident Ray 1)
        const incidentStartX = inX - rayLen * sin(theta1);
        const incidentStartY = filmTopY - rayLen * cos(theta1);
        
        let phase1 = time;
        drawWaveRay(incidentStartX, incidentStartY, inX, filmTopY, lambda, theta1, lightColor, phase1, incidentAlpha, incidentWeight);

        const dist_inc = dist(incidentStartX, incidentStartY, inX, filmTopY);
        const phase_at_surface = phase1 - k_air * dist_inc;

        // 2. 上面反射光 (Reflected Ray 1) - 個別の波
        const reflect1EndX = inX + rayLen * sin(theta1);
        const reflect1EndY = filmTopY - rayLen * cos(theta1);

        let phaseShift1 = 0;
        if (n1 < n2) phaseShift1 = PI;

        push();
        drawingContext.setLineDash([5, 5]); 
        let phase_refl1 = phase_at_surface + phaseShift1;
        // 破線
        drawWaveRay(inX, filmTopY, reflect1EndX, reflect1EndY, lambda, -theta1, lightColor, phase_refl1, 0.5, 2.0);
        pop();

        // 3. 屈折光 (Refracted Ray)
        const filmWaveScale = 1.0 / n2;
        const bottomX_in = inX + dx;
        
        let phase_refract = phase_at_surface;
        drawWaveRay(inX, filmTopY, bottomX_in, filmBottomY, lambda * filmWaveScale, -theta2, lightColor, phase_refract, filmAlpha, filmWeight);

        const dist_in = dist(inX, filmTopY, bottomX_in, filmBottomY);
        const visualLambdaFilm = lambda * filmWaveScale * RENDER_SCALE;
        const k_film = TWO_PI / visualLambdaFilm;
        const phase_at_bottom = phase_refract - k_film * dist_in;

        // 4. 下面反射光 (Reflected Ray inside film - 帰り)
        let phaseShift2 = 0;
        if (n2 < n3) phaseShift2 = PI;
        const bottomX_out = exitX - dx;

        if (visualOffset > 1) {
            push();
            stroke(150); // ガイド線をグレーに
            strokeWeight(1);
            drawingContext.setLineDash([2, 4]);
            line(bottomX_in, filmBottomY, bottomX_out, filmBottomY);
            drawingContext.setLineDash([]);
            pop();
        }

        let phase_return = phase_at_bottom + phaseShift2;
        drawWaveRay(bottomX_out, filmBottomY, exitX, filmTopY, lambda * filmWaveScale, theta2, lightColor, phase_return, filmAlpha, filmWeight);

        const dist_out = dist(bottomX_out, filmBottomY, exitX, filmTopY);
        const phase_at_exit = phase_return - k_film * dist_out;

        // --- 追加: 2本目の入射光 (Ray 1') ---
        const incidentStartX2 = exitX - rayLen * sin(theta1);
        const incidentStartY2 = filmTopY - rayLen * cos(theta1);
        
        const lateral_dist = exitX - inX;
        const geometric_path_diff = lateral_dist * sin(theta1);
        const geometric_phase_lag = k_air * geometric_path_diff;
        
        const phase_incident_at_exit_target = phase_at_surface - geometric_phase_lag;
        // drawWaveRayは始点からの距離で位相を計算するため、始点での位相を逆算
        const phase2_start = phase_incident_at_exit_target + k_air * dist_inc;

        drawWaveRay(incidentStartX2, incidentStartY2, exitX, filmTopY, lambda, theta1, lightColor, phase2_start, incidentAlpha, incidentWeight);
        
        // --- 2本目の入射光の反射波 (Reflection of Ray 1') ---
        const reflect2EndX = exitX + rayLen * sin(theta1);
        const reflect2EndY = filmTopY - rayLen * cos(theta1);
        
        let phase_refl2 = phase_incident_at_exit_target + phaseShift1;

        // 表面反射波（点線）
        push();
        drawingContext.setLineDash([5, 5]);
        drawWaveRay(exitX, filmTopY, reflect2EndX, reflect2EndY, lambda, -theta1, lightColor, phase_refl2, 0.5, 2.0);
        drawingContext.setLineDash([]); 
        pop();
        // ------------------------------------

        // 5. 透過・再放射光 (Reflected Ray 2 - emerging) - 個別の波
        let phase_emerge = phase_at_exit;

        // 透過・再放射光（点線）
        push();
        drawingContext.setLineDash([5, 5]); 
        drawWaveRay(exitX, filmTopY, reflect2EndX, reflect2EndY, lambda, -theta1, lightColor, phase_emerge, 0.5, 2.0);
        drawingContext.setLineDash([]); 
        pop();

        // --- 合成波 (Composite Wave) の描画 ---
        const compStartX = exitX;
        const compStartY = filmTopY;
        const compEndX = reflect2EndX;
        const compEndY = reflect2EndY;

        drawCompositeWave(compStartX, compStartY, compEndX, compEndY, lambda, lightColor, phase_refl2, phase_emerge);

        // --- 干渉結果の計算と表示 ---
        displayInterferenceResult(lambda, d, n2, n3, theta2, lightColor);
    }

    // 波線を描画する関数
    function drawWaveRay(x1, y1, x2, y2, lambda, angle, col, phaseOffset, alphaScale, weight = 2) {
        push();
        // 白背景なのでアルファ値はそのまま適用でOK
        stroke(col.r, col.g, col.b, 255 * alphaScale);
        strokeWeight(weight);
        noFill();

        translate(x1, y1);
        let rot = atan2(y2 - y1, x2 - x1);
        rotate(rot);

        let dist = sqrt(sq(x2 - x1) + sq(y2 - y1));
        // スケール統一
        let visualLambda = lambda * RENDER_SCALE; 
        // 振幅を大きく
        let amplitude = 12;

        beginShape();
        for (let x = 0; x <= dist; x += 2) {
            let k = TWO_PI / visualLambda;
            let y = amplitude * sin(k * x - phaseOffset);
            vertex(x, y);
        }
        endShape();

        // 中心線 (グレー)
        let currentDash = drawingContext.getLineDash();
        drawingContext.setLineDash([]); 
        stroke(150, 255 * alphaScale); // グレーの中心線
        strokeWeight(1);
        line(0, 0, dist, 0);
        drawingContext.setLineDash(currentDash); 

        pop();
    }

    // 合成波を描画する関数
    function drawCompositeWave(x1, y1, x2, y2, lambda, col, phase1, phase2) {
        push();
        // 合成波はくっきりと
        stroke(col.r, col.g, col.b, 255); 
        strokeWeight(3.0); // 太く
        noFill();

        translate(x1, y1);
        let rot = atan2(y2 - y1, x2 - x1);
        rotate(rot);

        let dist = sqrt(sq(x2 - x1) + sq(y2 - y1));
        // スケール統一
        let visualLambda = lambda * RENDER_SCALE; 
        // 合成波の基準振幅も合わせて調整
        let baseAmp = 12; 
        let ampFactor = 0.8;

        beginShape();
        for (let x = 0; x <= dist; x += 2) {
            let k = TWO_PI / visualLambda;
            // 合成: Ray 1 + Ray 2
            let y1_val = (baseAmp * ampFactor) * sin(k * x - phase1);
            let y2_val = (baseAmp * ampFactor) * sin(k * x - phase2);
            let y = y1_val + y2_val;
            vertex(x, y);
        }
        endShape();

        // 合成波のガイド線
        stroke(col.r, col.g, col.b, 80);
        strokeWeight(1);
        line(0, 0, dist, 0);
        
        pop();

        fill(col.r, col.g, col.b);
        noStroke();
        textSize(11);
        textAlign(LEFT);
        text("合成波", x2 + 5, y2);
    }

    function displayInterferenceResult(lambda, d, n2, n3, theta2, col) {
        let delta = 2 * n2 * d * cos(theta2);
        let shift1 = (n1 < n2) ? 0.5 : 0;
        let shift2 = (n2 < n3) ? 0.5 : 0;
        let totalShift = Math.abs(shift1 - shift2);
        
        let pathRatio = delta / lambda;
        let interferenceValue = cos(TWO_PI * (pathRatio + totalShift)); 

        let boxW = 130; 
        let boxH = 160; 
        
        // 画面が狭い場合、干渉結果BOXの位置を調整
        let boxX, boxY;
        if (width < 600) {
            // モバイル：右下など邪魔にならない位置へ
            boxX = width - 70;
            boxY = height - 90;
            // モバイルでは少し小さく表示してもいいが、ここでは位置変更のみ
        } else {
            boxX = width - 80; 
            boxY = 100;
        }

        push();
        translate(boxX, boxY);
        
        // パネル背景（白半透明）
        fill(255, 255, 255, 220);
        stroke(200); // 枠線
        rect(-boxW/2, -20, boxW, boxH, 8);
        
        noStroke();
        fill(50); // 黒文字
        textAlign(CENTER);
        textSize(11);
        text("干渉結果 (Interference)", 0, 0);

        let intensity = map(interferenceValue, -1, 1, 0, 1);
        let alpha = intensity * 255;
        
        let circleSize = 60;
        let circleY = 60;

        // 背景円（薄いグレー）
        fill(240);
        ellipse(0, circleY, circleSize, circleSize);

        // 結果円
        fill(col.r, col.g, col.b, alpha);
        ellipse(0, circleY, circleSize, circleSize);
        
        if (intensity > 0.8) {
            drawingContext.shadowBlur = 30;
            drawingContext.shadowColor = `rgb(${col.r},${col.g},${col.b})`;
            ellipse(0, circleY, circleSize, circleSize);
            drawingContext.shadowBlur = 0;
        }

        fill(50);
        textSize(11);
        let statusText = "";
        if (intensity > 0.9) statusText = "強め合い";
        else if (intensity < 0.1) statusText = "弱め合い";
        else statusText = "中間";
        
        text(statusText, 0, circleY + 50);
        
        textSize(9);
        fill(100);
        text(`OPD Δ ≈ ${Math.round(delta)} nm`, 0, circleY + 70);
        text(`反射位相差: ${totalShift * 360}°`, 0, circleY + 82);
        
        pop();
    }

    function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
    }

    function wavelengthToColor(wavelength) {
        var r, g, b;
        if (wavelength >= 380 && wavelength < 440) {
            r = -1 * (wavelength - 440) / (440 - 380);
            g = 0;
            b = 1;
        } else if (wavelength >= 440 && wavelength < 490) {
            r = 0;
            g = (wavelength - 440) / (490 - 440);
            b = 1;
        } else if (wavelength >= 490 && wavelength < 510) {
            r = 0;
            g = 1;
            b = -1 * (wavelength - 510) / (510 - 490);
        } else if (wavelength >= 510 && wavelength < 580) {
            r = (wavelength - 510) / (580 - 510);
            g = 1;
            b = 0;
        } else if (wavelength >= 580 && wavelength < 645) {
            r = 1;
            g = -1 * (wavelength - 645) / (645 - 580);
            b = 0;
        } else if (wavelength >= 645 && wavelength <= 750) {
            r = 1;
            g = 0;
            b = 0;
        } else {
            r = 0;
            g = 0;
            b = 0;
        }
        
        let factor = 1.0;
        if (wavelength >= 380 && wavelength < 420){
            factor = 0.3 + 0.7*(wavelength - 380) / (420 - 380);
        }else if(wavelength >= 380 && wavelength <= 700){
            factor = 1.0;
        }else if(wavelength > 700 && wavelength <= 750){
            factor = 0.3 + 0.7*(750 - wavelength) / (750 - 700);
        } else {
            factor = 0;
        }

        return {
            r: Math.floor(r * 255 * factor),
            g: Math.floor(g * 255 * factor),
            b: Math.floor(b * 255 * factor)
        };
    }
</script>

</body>
</html>
